diff --git a/dist/chunk-354SINOH.js b/dist/chunk-354SINOH.js
index 7f87776370b755bf04765b8a0ae0145bf3a0b5e6..3b6d011fd5953abea392f0723dfedd52bf061a44 100644
--- a/dist/chunk-354SINOH.js
+++ b/dist/chunk-354SINOH.js
@@ -10,7 +10,7 @@ var _basecontroller = require('@metamask/base-controller');
 
 
 
-
+var _chunkNYVA7ZTQjs = require('./chunk-NYVA7ZTQ.js');
 
 
 
@@ -25,6 +25,7 @@ var BlockaidResultType = /* @__PURE__ */ ((BlockaidResultType2) => {
   BlockaidResultType2["Malicious"] = "Malicious";
   return BlockaidResultType2;
 })(BlockaidResultType || {});
+var MAX_GET_COLLECTION_BATCH_SIZE = 20;
 var _disabled, _addNft, _getNftState, _inProcessNftFetchingUpdates, _onPreferencesControllerStateChange, onPreferencesControllerStateChange_fn, _getOwnerNftApi, getOwnerNftApi_fn, _getOwnerNfts, getOwnerNfts_fn;
 var NftDetectionController = class extends _basecontroller.BaseController {
   /**
@@ -134,6 +135,56 @@ var NftDetectionController = class extends _basecontroller.BaseController {
         apiNfts = resultNftApi.tokens.filter(
           (elm) => elm.token.isSpam === false && (elm.blockaidResult?.result_type ? elm.blockaidResult?.result_type === "Benign" /* Benign */ : true)
         );
+        const collections = apiNfts.reduce((acc, currValue) => {
+          if (!acc.includes(currValue.token.contract)) {
+            acc.push(currValue.token.contract);
+          }
+          return acc;
+        }, []);
+        const collectionResponse = await _chunkNYVA7ZTQjs.reduceInBatchesSerially.call(void 0, {
+          values: collections,
+          batchSize: MAX_GET_COLLECTION_BATCH_SIZE,
+          eachBatch: async (allResponses, batch) => {
+            const params = new URLSearchParams(
+              batch.map((s) => ["contract", s])
+            );
+            params.append("chainId", "1");
+            const collectionResponseForBatch = await _controllerutils.fetchWithErrorHandling.call(void 0, {
+              url: `${_controllerutils.NFT_API_BASE_URL}/collections?${params.toString()}`,
+              options: {
+                headers: {
+                  Version: '1'
+                }
+              },
+              timeout: _controllerutils.NFT_API_TIMEOUT
+            });
+            return {
+              ...allResponses,
+              ...collectionResponseForBatch
+            };
+          },
+          initialResult: {}
+        });
+        if (collectionResponse.collections?.length) {
+          apiNfts.forEach((singleNFT) => {
+            const found = collectionResponse.collections.find(
+              (elm) => elm.id?.toLowerCase() === singleNFT.token.contract.toLowerCase()
+            );
+            if (found) {
+              singleNFT.token = {
+                ...singleNFT.token,
+                collection: {
+                  ...singleNFT.token.collection ? singleNFT.token.collection : {},
+                  creator: found?.creator,
+                  openseaVerificationStatus: found?.openseaVerificationStatus,
+                  contractDeployedAt: found.contractDeployedAt,
+                  ownerCount: found.ownerCount,
+                  topBid: found.topBid
+                }
+              };
+            }
+          });
+        }
         const addNftPromises = apiNfts.map(async (nft) => {
           const {
             tokenId,
diff --git a/dist/chunk-7JWDWDXT.js b/dist/chunk-7JWDWDXT.js
index af5d78416658763da52305f9e08b286733310898..d4d13c8488844a7c419bf0ae16a0c7f31800216a 100644
--- a/dist/chunk-7JWDWDXT.js
+++ b/dist/chunk-7JWDWDXT.js
@@ -873,14 +873,32 @@ getNftInformationFromApi_fn = async function(contractAddress, tokenId) {
     includeAttributes: "true",
     includeLastSale: "true"
   }).toString();
-  const nftInformation = await _controllerutils.fetchWithErrorHandling.call(void 0, {
-    url: `${this.getNftApi()}?${urlParams}`,
-    options: {
-      headers: {
-        Version: "1"
-      }
-    }
-  });
+  const getCollectionParams = new URLSearchParams({
+    chainIds: "1",
+    contract: `${contractAddress}`
+  }).toString();
+  const [nftInformation, collectionInformation] = await Promise.all([
+    _controllerutils.safelyExecute.call(void 0,
+      () => _controllerutils.fetchWithErrorHandling.call(void 0, {
+        url: `${this.getNftApi()}?${urlParams}`,
+        options: {
+          headers: {
+            Version: "1"
+          }
+        }
+      })
+    ),
+    _controllerutils.safelyExecute.call(void 0,
+      () => _controllerutils.fetchWithErrorHandling.call(void 0, {
+        url: `${_controllerutils.NFT_API_BASE_URL}/collections?${getCollectionParams}`,
+        options: {
+          headers: {
+            Version: "1"
+          }
+        }
+      })
+    )
+  ]);
   if (!nftInformation?.tokens?.[0]?.token) {
     return {
       name: null,
@@ -918,7 +936,16 @@ getNftInformationFromApi_fn = async function(contractAddress, tokenId) {
     },
     rarityRank && { rarityRank },
     rarity && { rarity },
-    collection && { collection }
+    (collection || collectionInformation) && {
+      collection: {
+        ...collection || {},
+        creator: collection?.creator || collectionInformation?.collections[0].creator,
+        openseaVerificationStatus: collectionInformation?.collections[0].openseaVerificationStatus,
+        contractDeployedAt: collectionInformation?.collections[0].contractDeployedAt,
+        ownerCount: collectionInformation?.collections[0].ownerCount,
+        topBid: collectionInformation?.collections[0].topBid
+      }
+    }
   );
   return nftMetadata;
 };
@@ -1095,7 +1122,8 @@ addIndividualNft_fn = async function(tokenAddress, tokenId, nftMetadata, nftCont
         nftMetadata,
         existingEntry
       );
-      if (!differentMetadata && existingEntry.isCurrentlyOwned) {
+      const hasNewFields = _chunkNYVA7ZTQjs.hasNewCollectionFields.call(void 0, nftMetadata, existingEntry);
+      if (!differentMetadata && existingEntry.isCurrentlyOwned && !hasNewFields) {
         return;
       }
       const indexToUpdate = nfts.findIndex(
diff --git a/dist/chunk-NYVA7ZTQ.js b/dist/chunk-NYVA7ZTQ.js
index f31fdabedc067227407a6320e57a670f86b972f4..c0ff7ece56dc5f3e68149d114ff16f7d10eb1741 100644
--- a/dist/chunk-NYVA7ZTQ.js
+++ b/dist/chunk-NYVA7ZTQ.js
@@ -27,6 +27,11 @@ function compareNftMetadata(newNftMetadata, nft) {
   }, 0);
   return differentValues > 0;
 }
+function hasNewCollectionFields(newNftMetadata, nft) {
+  const keysNewNftMetadata = Object.keys(newNftMetadata.collection || {});
+  const keysExistingNft = new Set(Object.keys(nft.collection || {}));
+  return keysNewNftMetadata.some((key) => !keysExistingNft.has(key));
+}
 var aggregatorNameByKey = {
   aave: "Aave",
   bancor: "Bancor",
@@ -205,5 +210,5 @@ async function fetchTokenContractExchangeRates({
 
 
 
-exports.TOKEN_PRICES_BATCH_SIZE = TOKEN_PRICES_BATCH_SIZE; exports.compareNftMetadata = compareNftMetadata; exports.formatAggregatorNames = formatAggregatorNames; exports.formatIconUrlWithProxy = formatIconUrlWithProxy; exports.SupportedTokenDetectionNetworks = SupportedTokenDetectionNetworks; exports.isTokenDetectionSupportedForNetwork = isTokenDetectionSupportedForNetwork; exports.isTokenListSupportedForNetwork = isTokenListSupportedForNetwork; exports.removeIpfsProtocolPrefix = removeIpfsProtocolPrefix; exports.getIpfsCIDv1AndPath = getIpfsCIDv1AndPath; exports.getFormattedIpfsUrl = getFormattedIpfsUrl; exports.addUrlProtocolPrefix = addUrlProtocolPrefix; exports.ethersBigNumberToBN = ethersBigNumberToBN; exports.divideIntoBatches = divideIntoBatches; exports.reduceInBatchesSerially = reduceInBatchesSerially; exports.fetchTokenContractExchangeRates = fetchTokenContractExchangeRates;
+exports.TOKEN_PRICES_BATCH_SIZE = TOKEN_PRICES_BATCH_SIZE; exports.compareNftMetadata = compareNftMetadata; exports.hasNewCollectionFields = hasNewCollectionFields; exports.formatAggregatorNames = formatAggregatorNames; exports.formatIconUrlWithProxy = formatIconUrlWithProxy; exports.SupportedTokenDetectionNetworks = SupportedTokenDetectionNetworks; exports.isTokenDetectionSupportedForNetwork = isTokenDetectionSupportedForNetwork; exports.isTokenListSupportedForNetwork = isTokenListSupportedForNetwork; exports.removeIpfsProtocolPrefix = removeIpfsProtocolPrefix; exports.getIpfsCIDv1AndPath = getIpfsCIDv1AndPath; exports.getFormattedIpfsUrl = getFormattedIpfsUrl; exports.addUrlProtocolPrefix = addUrlProtocolPrefix; exports.ethersBigNumberToBN = ethersBigNumberToBN; exports.divideIntoBatches = divideIntoBatches; exports.reduceInBatchesSerially = reduceInBatchesSerially; exports.fetchTokenContractExchangeRates = fetchTokenContractExchangeRates;
 //# sourceMappingURL=chunk-NYVA7ZTQ.js.map
\ No newline at end of file
